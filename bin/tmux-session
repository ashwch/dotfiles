#!/usr/bin/env bash
#
# tmux-session - Smart tmux session launcher for Ghostty
#
# Features:
#   - Interactive session picker with fzf
#   - Shows existing sessions with their working directories
#   - Create new sessions with custom names
#   - Browse directories via zoxide integration (Ctrl-f)
#   - Type a path directly to cd and create session there
#   - Unique session names using directory + hash (worktree-safe)
#
# Usage:
#   tmux-session              # Interactive picker
#   tmux-session <name>       # Attach or create named session
#   tmux-session -h|--help    # Show help
#
# Requirements: tmux, fzf, zoxide (optional)
#

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

readonly VERSION="1.0.0"
SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_NAME

# Colors for output
readonly RED='\033[0;31m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# =============================================================================
# Utility Functions
# =============================================================================

die() {
    echo -e "${RED}error:${NC} $*" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}warning:${NC} $*" >&2
}

info() {
    echo -e "${BLUE}::${NC} $*" >&2
}

# Find command in PATH or common locations
find_command() {
    local cmd="$1"

    # Check PATH first
    if command -v "$cmd" &>/dev/null; then
        command -v "$cmd"
        return 0
    fi

    # Check common Homebrew locations
    local locations=(
        "/opt/homebrew/bin/$cmd"
        "/usr/local/bin/$cmd"
        "/usr/bin/$cmd"
    )

    for loc in "${locations[@]}"; do
        if [[ -x "$loc" ]]; then
            echo "$loc"
            return 0
        fi
    done

    return 1
}

# =============================================================================
# Dependency Resolution
# =============================================================================

resolve_dependencies() {
    TMUX=$(find_command tmux) || die "tmux not found. Install with: brew install tmux"
    FZF=$(find_command fzf) || die "fzf not found. Install with: brew install fzf"
    ZOXIDE=$(find_command zoxide) || ZOXIDE=""  # Optional

    # Verify tmux works
    $TMUX -V &>/dev/null || die "tmux is not working correctly"
}

# =============================================================================
# Session Management
# =============================================================================

# Get list of existing tmux sessions
get_sessions() {
    $TMUX list-sessions -F "#{session_name}" 2>/dev/null || true
}

# Generate a unique session name from a directory path
generate_session_name() {
    local dir="${1:-$PWD}"
    local name

    if [[ "$dir" == "$HOME" ]]; then
        echo "main"
        return
    fi

    local base hash
    base=$(basename "$dir")
    hash=$(echo -n "$dir" | md5 2>/dev/null || md5sum | cut -d' ' -f1)
    hash="${hash:0:6}"

    name="${base}-${hash}"

    # Sanitize: tmux session names can't have dots or colons
    name="${name//./-}"
    name="${name//:/-}"

    echo "$name"
}

# Shorten path for display (replace $HOME with ~)
shorten_path() {
    local path="$1"
    echo "${path/#$HOME/~}"
}

# =============================================================================
# UI Components
# =============================================================================

# Build the session selection list
build_session_list() {
    echo "[+] Create new session"

    if [[ -n "$ZOXIDE" ]]; then
        echo "[~] Pick directory (Ctrl-f)"
    fi

    get_sessions | while read -r session; do
        [[ -z "$session" ]] && continue

        # Get the current path of the active pane
        local pane_path
        pane_path=$($TMUX display-message -t "$session" -p "#{pane_current_path}" 2>/dev/null) || pane_path="?"
        pane_path=$(shorten_path "$pane_path")

        printf "%s  │  %s\n" "$session" "$pane_path"
    done
}

# Directory picker using zoxide
pick_directory() {
    [[ -z "$ZOXIDE" ]] && return 1

    $ZOXIDE query -l 2>/dev/null | $FZF \
        --height=60% \
        --layout=reverse \
        --border=rounded \
        --prompt="directory › " \
        --header="Select directory for new session (ESC to cancel)" \
        --preview="ls -la --color=always {} 2>/dev/null || ls -la {}" \
        --preview-window=right:40%:wrap \
        --color=header:italic \
        --no-info
}

# Main session picker
show_picker() {
    local current_dir
    current_dir=$(shorten_path "$PWD")

    local header="Current: $current_dir"
    if [[ -n "$ZOXIDE" ]]; then
        header="$header
Select session, type name, or Ctrl-f for directory"
    else
        header="$header
Select session or type name"
    fi

    local fzf_opts=(
        --height=50%
        --layout=reverse
        --border=rounded
        --prompt="session › "
        --header="$header"
        --header-first
        --print-query
        --color=header:italic
        --no-info
    )

    if [[ -n "$ZOXIDE" ]]; then
        fzf_opts+=("--expect=enter,ctrl-f")
    else
        fzf_opts+=("--expect=enter")
    fi

    build_session_list | $FZF "${fzf_opts[@]}"
}

# =============================================================================
# Session Actions
# =============================================================================

# Create or attach to a session in a specific directory
create_session_in_dir() {
    local target_dir="$1"

    if [[ ! -d "$target_dir" ]]; then
        die "Directory does not exist: $target_dir"
    fi

    cd "$target_dir" || die "Cannot cd to: $target_dir"

    local session_name
    session_name=$(generate_session_name "$target_dir")

    exec $TMUX new-session -A -s "$session_name"
}

# Create or attach to a named session
create_or_attach() {
    local session_name="$1"

    # Sanitize the name
    session_name="${session_name//./-}"
    session_name="${session_name//:/-}"

    exec $TMUX new-session -A -s "$session_name"
}

# Attach to an existing session
attach_session() {
    local session_name="$1"
    exec $TMUX attach-session -t "=$session_name"
}

# =============================================================================
# Main Logic
# =============================================================================

process_selection() {
    local selection="$1"

    # Parse fzf output
    local query key choice
    query=$(echo "$selection" | sed -n '1p')
    key=$(echo "$selection" | sed -n '2p')
    choice=$(echo "$selection" | sed -n '3p')

    # Handle Ctrl-f (directory picker)
    if [[ "$key" == "ctrl-f" ]] || [[ "$choice" == "[~] Pick directory (Ctrl-f)" ]]; then
        local target_dir
        target_dir=$(pick_directory) || true

        if [[ -n "$target_dir" && -d "$target_dir" ]]; then
            create_session_in_dir "$target_dir"
        else
            # User cancelled - fall back to main
            create_or_attach "main"
        fi
        return
    fi

    # Handle empty selection (ESC or empty)
    if [[ -z "$choice" && -z "$query" ]]; then
        create_or_attach "main"
        return
    fi

    # Handle "Create new session" or typed query
    if [[ "$choice" == "[+] Create new session" ]] || [[ -z "$choice" ]]; then
        if [[ -n "$query" ]]; then
            # Check if query looks like a path
            if [[ "$query" == /* || "$query" == ~* || "$query" == .* ]]; then
                local target_dir="${query/#\~/$HOME}"
                if [[ -d "$target_dir" ]]; then
                    create_session_in_dir "$target_dir"
                else
                    # Not a valid directory, use as session name
                    create_or_attach "$query"
                fi
            else
                # Regular session name
                create_or_attach "$query"
            fi
        else
            # No query, generate name from current directory
            local session_name
            session_name=$(generate_session_name)
            create_or_attach "$session_name"
        fi
        return
    fi

    # Handle existing session selection
    # Extract session name (everything before "  │ ")
    local session_name
    session_name="${choice%%  │*}"
    attach_session "$session_name"
}

show_help() {
    cat <<EOF
${SCRIPT_NAME} v${VERSION} - Smart tmux session launcher

USAGE:
    ${SCRIPT_NAME} [OPTIONS] [SESSION_NAME]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version

ARGUMENTS:
    SESSION_NAME    Directly attach or create a named session

INTERACTIVE MODE:
    When run without arguments, shows an fzf picker with:

    • Existing sessions (with their working directories)
    • [+] Create new session
    • [~] Pick directory (requires zoxide)

    Type to filter or enter a new session name.
    Type a path (~/foo, /bar) to cd there and create session.
    Press Ctrl-f to browse zoxide history.

EXAMPLES:
    ${SCRIPT_NAME}              # Interactive picker
    ${SCRIPT_NAME} myproject    # Attach/create 'myproject' session
    ${SCRIPT_NAME} ~/code/app   # Create session in ~/code/app

REQUIREMENTS:
    tmux    Required
    fzf     Required
    zoxide  Optional (enables directory picker)

EOF
}

main() {
    # Handle arguments
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "${SCRIPT_NAME} v${VERSION}"
            exit 0
            ;;
        "")
            # Interactive mode
            ;;
        *)
            # Direct session name or path
            resolve_dependencies

            if [[ -d "$1" ]]; then
                create_session_in_dir "$1"
            else
                create_or_attach "$1"
            fi
            exit 0
            ;;
    esac

    # Resolve dependencies
    resolve_dependencies

    # Show picker and process selection
    local selection
    selection=$(show_picker) || true

    if [[ -z "$selection" ]]; then
        # fzf was cancelled
        create_or_attach "main"
    else
        process_selection "$selection"
    fi
}

main "$@"
